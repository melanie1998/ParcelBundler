"use strict";

function _core() {
  const data = require("@parcel/core");

  _core = function () {
    return data;
  };

  return data;
}

function _packageManager() {
  const data = require("@parcel/package-manager");

  _packageManager = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = require("@parcel/fs");

  _fs = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = _interopRequireDefault(require("@parcel/diagnostic"));

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _events() {
  const data = require("@parcel/events");

  _events = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@parcel/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _commander() {
  const data = _interopRequireDefault(require("commander"));

  _commander = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _getPort() {
  const data = _interopRequireDefault(require("get-port"));

  _getPort = function () {
    return data;
  };

  return data;
}

function _package() {
  const data = require("../package.json");

  _package = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

require('v8-compile-cache');

async function logUncaughtError(e) {
  if (e instanceof _diagnostic().default) {
    for (let diagnostic of e.diagnostics) {
      let out = await (0, _utils().prettyDiagnostic)(diagnostic);

      _logger().INTERNAL_ORIGINAL_CONSOLE.error(out.message);

      _logger().INTERNAL_ORIGINAL_CONSOLE.error(out.codeframe || out.stack);

      for (let h of out.hints) {
        _logger().INTERNAL_ORIGINAL_CONSOLE.error(h);
      }
    }
  } else {
    _logger().INTERNAL_ORIGINAL_CONSOLE.error(e);
  } // A hack to definitely ensure we logged the uncaught exception


  await new Promise(resolve => setTimeout(resolve, 100));
}

process.on('unhandledRejection', async reason => {
  await logUncaughtError(reason);
  process.exit();
}); // Capture the NODE_ENV this process was launched with, so that it can be
// used in Parcel (such as in process.env inlining).

const initialNodeEnv = process.env.NODE_ENV; // Then, override NODE_ENV to be PARCEL_BUILD_ENV (replaced with `production` in builds)
// so that dependencies of Parcel like React (which renders the cli through `ink`)
// run in the appropriate mode.

process.env.NODE_ENV = "production";

_commander().default.version(_package().version); // --no-cache, --cache-dir, --no-source-maps, --no-autoinstall, --global?, --public-url, --log-level
// --no-content-hash, --experimental-scope-hoisting, --detailed-report


const commonOptions = {
  '--no-cache': 'disable the filesystem cache',
  '--config <path>': 'specify which config to use. can be a path or a package name',
  '--cache-dir <path>': 'set the cache directory. defaults to ".parcel-cache"',
  '--no-source-maps': 'disable sourcemaps',
  '--no-content-hash': 'disable content hashing',
  '--target [name]': ['only build given target(s)', (val, list) => list.concat([val]), []],
  '--log-level <level>': ['set the log level, either "none", "error", "warn", "info", or "verbose".', /^(none|error|warn|info|verbose)$/],
  '--dist-dir <dir>': 'output directory to write to when unspecified by targets',
  '--profile': 'enable build profiling',
  '-V, --version': 'output the version number',
  '--detailed-report [depth]': ['Print the asset timings and sizes in the build report', /^([0-9]+)$/]
};
var hmrOptions = {
  '--no-hmr': 'disable hot module replacement',
  '-p, --port <port>': ['set the port to serve on. defaults to $PORT or 1234', value => parseInt(value, 10), parseInt(process.env.PORT, 10) || 1234],
  '--host <host>': 'set the host to listen on, defaults to listening on all interfaces',
  '--https': 'serves files over HTTPS',
  '--cert <path>': 'path to certificate to use with HTTPS',
  '--key <path>': 'path to private key to use with HTTPS',
  '--no-autoinstall': 'disable autoinstall'
};

function applyOptions(cmd, options) {
  for (let opt in options) {
    cmd.option(opt, ...(Array.isArray(options[opt]) ? options[opt] : [options[opt]]));
  }
}

let serve = _commander().default.command('serve [input...]').description('starts a development server').option('--public-url <url>', 'the path prefix for absolute urls').option('--open [browser]', 'automatically open in specified browser, defaults to default browser').option('--watch-for-stdin', 'exit when stdin closes').action(run);

applyOptions(serve, hmrOptions);
applyOptions(serve, commonOptions);

let watch = _commander().default.command('watch [input...]').description('starts the bundler in watch mode').option('--public-url <url>', 'the path prefix for absolute urls').option('--watch-for-stdin', 'exit when stdin closes').action(run);

applyOptions(watch, hmrOptions);
applyOptions(watch, commonOptions);

let build = _commander().default.command('build [input...]').description('bundles for production').option('--no-minify', 'disable minification').option('--no-scope-hoist', 'disable scope-hoisting').option('--public-url <url>', 'the path prefix for absolute urls').action(run);

applyOptions(build, commonOptions);

_commander().default.command('help [command]').description('display help information for a command').action(function (command) {
  let cmd = _commander().default.commands.find(c => c.name() === command) || _commander().default;

  cmd.help();
});

_commander().default.on('--help', function () {
  _logger().INTERNAL_ORIGINAL_CONSOLE.log('');

  _logger().INTERNAL_ORIGINAL_CONSOLE.log('  Run `' + _chalk().default.bold('parcel help <command>') + '` for more information on specific commands');

  _logger().INTERNAL_ORIGINAL_CONSOLE.log('');
}); // Make serve the default command except for --help


var args = process.argv;
if (args[2] === '--help' || args[2] === '-h') args[2] = 'help';

if (!args[2] || !_commander().default.commands.some(c => c.name() === args[2])) {
  args.splice(2, 0, 'serve');
}

_commander().default.parse(args);

async function run(entries, command) {
  entries = entries.map(entry => _path().default.resolve(entry));

  if (entries.length === 0) {
    _logger().INTERNAL_ORIGINAL_CONSOLE.log('No entries found');

    return;
  }

  let Parcel = require('@parcel/core').default;

  let options = await normalizeOptions(command);
  let packageManager = new (_packageManager().NodePackageManager)(new (_fs().NodeFS)());
  let parcel = new Parcel({
    entries,
    packageManager,
    defaultConfig: '@parcel/config-default',
    patchConsole: true,
    ...options
  });
  let disposable = new (_events().Disposable)();
  let unsubscribe;
  let isExiting;

  async function exit(exitCode = 0) {
    if (isExiting) {
      return;
    }

    isExiting = true;

    if (unsubscribe != null) {
      await unsubscribe();
    } else if (parcel.isProfiling) {
      await parcel.stopProfiling();
    }

    disposable.dispose();
    process.exit(exitCode);
  }

  if (process.stdin.isTTY) {
    // $FlowFixMe
    process.stdin.setRawMode(true);

    require('readline').emitKeypressEvents(process.stdin);

    let stream = process.stdin.on('keypress', async (char, key) => {
      if (!key.ctrl) {
        return;
      }

      switch (key.name) {
        case 'c':
          // Detect the ctrl+c key, and gracefully exit after writing the asset graph to the cache.
          // This is mostly for tools that wrap Parcel as a child process like yarn and npm.
          //
          // Setting raw mode prevents SIGINT from being sent in response to ctrl-c:
          // https://nodejs.org/api/tty.html#tty_readstream_setrawmode_mode
          //
          // We don't use the SIGINT event for this because when run inside yarn, the parent
          // yarn process ends before Parcel and it appears that Parcel has ended while it may still
          // be cleaning up. Handling events from stdin prevents this impression.
          await exit(1);
          break;

        case 'e':
          await (parcel.isProfiling ? parcel.stopProfiling() : parcel.startProfiling());
          break;
      }
    });
    disposable.add(() => {
      stream.destroy();
    });
  }

  if (command.name() === 'watch' || command.name() === 'serve') {
    ({
      unsubscribe
    } = await parcel.watch(err => {
      if (err) {
        throw err;
      }
    }));

    if (command.open && options.serve) {
      await (0, _utils().openInBrowser)(`${options.serve.https ? 'https' : 'http'}://${options.serve.host || 'localhost'}:${options.serve.port}`, command.open);
    }

    if (command.watchForStdin) {
      process.stdin.on('end', async () => {
        _logger().INTERNAL_ORIGINAL_CONSOLE.log('STDIN closed, ending');

        await exit();
      });
      process.stdin.resume();
    } // In non-tty cases, respond to SIGINT by cleaning up.


    process.on('SIGINT', exit);
    process.on('SIGTERM', exit);
  } else {
    try {
      await parcel.run();
    } catch (e) {
      // If an exception is thrown during Parcel.build, it is given to reporters in a
      // buildFailure event, and has been shown to the user.
      if (!(e instanceof _core().BuildError)) {
        await logUncaughtError(e);
      }

      await exit(1);
    }

    await exit();
  }
}

async function normalizeOptions(command) {
  var _command$sourceMaps, _command$autoinstall;

  let nodeEnv;

  if (command.name() === 'build') {
    nodeEnv = initialNodeEnv || 'production';
    command.autoinstall = false;
  } else {
    nodeEnv = initialNodeEnv || 'development';
  }

  let https = !!command.https;

  if (command.cert && command.key) {
    https = {
      cert: command.cert,
      key: command.key
    };
  }

  let serve = false;
  let {
    port,
    host
  } = command;

  if (command.name() === 'serve' || command.hmr) {
    port = await (0, _getPort().default)({
      port,
      host
    });

    if (command.port && port !== command.port) {
      // Parcel logger is not set up at this point, so just use native INTERNAL_ORIGINAL_CONSOLE.
      _logger().INTERNAL_ORIGINAL_CONSOLE.warn(_chalk().default.bold.yellowBright(`⚠️  Port ${command.port} could not be used.`));
    }
  }

  if (command.name() === 'serve') {
    let {
      publicUrl
    } = command;
    serve = {
      https,
      port,
      host,
      publicUrl
    };
  }

  let hmr = null;

  if (command.name() !== 'build' && command.hmr !== false) {
    hmr = {
      port,
      host
    };
  }

  let mode = command.name() === 'build' ? 'production' : 'development';
  return {
    disableCache: command.cache === false,
    cacheDir: command.cacheDir,
    mode,
    minify: command.minify != null ? command.minify : mode === 'production',
    sourceMaps: (_command$sourceMaps = command.sourceMaps) !== null && _command$sourceMaps !== void 0 ? _command$sourceMaps : true,
    scopeHoist: command.scopeHoist,
    publicUrl: command.publicUrl,
    distDir: command.distDir,
    hot: hmr,
    contentHash: hmr ? false : command.contentHash,
    serve,
    targets: command.target.length > 0 ? command.target : null,
    autoinstall: (_command$autoinstall = command.autoinstall) !== null && _command$autoinstall !== void 0 ? _command$autoinstall : true,
    logLevel: command.logLevel,
    profile: command.profile,
    detailedReport: command.detailedReport,
    env: {
      NODE_ENV: nodeEnv
    }
  };
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAsset = createAsset;
exports.generateFromAST = generateFromAST;
exports.getConfig = getConfig;

function _stream() {
  const data = require("stream");

  _stream = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@parcel/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _CommittedAsset() {
  const data = _interopRequireDefault(require("./CommittedAsset"));

  _CommittedAsset = function () {
    return data;
  };

  return data;
}

function _UncommittedAsset() {
  const data = _interopRequireDefault(require("./UncommittedAsset"));

  _UncommittedAsset = function () {
    return data;
  };

  return data;
}

function _loadParcelPlugin() {
  const data = _interopRequireDefault(require("./loadParcelPlugin"));

  _loadParcelPlugin = function () {
    return data;
  };

  return data;
}

function _Asset() {
  const data = require("./public/Asset");

  _Asset = function () {
    return data;
  };

  return data;
}

function _PluginOptions() {
  const data = _interopRequireDefault(require("./public/PluginOptions"));

  _PluginOptions = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _Environment() {
  const data = require("./Environment");

  _Environment = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createAsset(options) {
  var _options$pipeline, _options$committed, _options$isIsolated, _options$isInline, _options$symbols, _options$sideEffects;

  let idBase = options.idBase != null ? options.idBase : options.filePath;
  let uniqueKey = options.uniqueKey || '';
  return {
    id: options.id != null ? options.id : (0, _utils().md5FromString)(idBase + options.type + (0, _Environment().getEnvironmentHash)(options.env) + uniqueKey + ((_options$pipeline = options.pipeline) !== null && _options$pipeline !== void 0 ? _options$pipeline : '')),
    committed: (_options$committed = options.committed) !== null && _options$committed !== void 0 ? _options$committed : false,
    hash: options.hash,
    filePath: options.filePath,
    query: options.query || {},
    isIsolated: (_options$isIsolated = options.isIsolated) !== null && _options$isIsolated !== void 0 ? _options$isIsolated : false,
    isInline: (_options$isInline = options.isInline) !== null && _options$isInline !== void 0 ? _options$isInline : false,
    isSplittable: options.isSplittable,
    type: options.type,
    contentKey: options.contentKey,
    mapKey: options.mapKey,
    astKey: options.astKey,
    astGenerator: options.astGenerator,
    dependencies: options.dependencies || new Map(),
    includedFiles: options.includedFiles || new Map(),
    isSource: options.isSource,
    outputHash: options.outputHash,
    pipeline: options.pipeline,
    env: options.env,
    meta: options.meta || {},
    stats: options.stats,
    symbols: (_options$symbols = options.symbols) !== null && _options$symbols !== void 0 ? _options$symbols : options.symbols === null ? null : new Map(),
    sideEffects: (_options$sideEffects = options.sideEffects) !== null && _options$sideEffects !== void 0 ? _options$sideEffects : true,
    uniqueKey: uniqueKey,
    plugin: options.plugin,
    configPath: options.configPath,
    configKeyPath: options.configKeyPath
  };
}

const generateResults = new WeakMap();

function generateFromAST(asset) {
  let output = generateResults.get(asset.value);

  if (output == null) {
    output = _generateFromAST(asset);
    generateResults.set(asset.value, output);
  }

  return output;
}

async function _generateFromAST(asset) {
  let ast = await asset.getAST();

  if (ast == null) {
    throw new Error('Asset has no AST');
  }

  let pluginName = (0, _nullthrows().default)(asset.value.plugin);
  let {
    plugin
  } = await (0, _loadParcelPlugin().default)(asset.options.inputFS, asset.options.packageManager, pluginName, (0, _nullthrows().default)(asset.value.configPath), (0, _nullthrows().default)(asset.value.configKeyPath), asset.options.autoinstall);

  if (!plugin.generate) {
    throw new Error(`${pluginName} does not have a generate method`);
  }

  let {
    content,
    map
  } = await plugin.generate({
    asset: new (_Asset().Asset)(asset),
    ast,
    options: new (_PluginOptions().default)(asset.options),
    logger: new (_logger().PluginLogger)({
      origin: pluginName
    })
  });
  let mapBuffer = map === null || map === void 0 ? void 0 : map.toBuffer(); // Store the results in the cache so we can avoid generating again next time

  await Promise.all([asset.options.cache.setStream((0, _nullthrows().default)(asset.value.contentKey), (0, _utils().blobToStream)(content)), mapBuffer != null && asset.options.cache.setBlob((0, _nullthrows().default)(asset.value.mapKey), mapBuffer)]);
  return {
    content: content instanceof _stream().Readable ? asset.options.cache.getStream((0, _nullthrows().default)(asset.value.contentKey)) : content,
    map
  };
}

async function getConfig(asset, filePaths, options) {
  let packageKey = options === null || options === void 0 ? void 0 : options.packageKey;
  let parse = options && options.parse;

  if (packageKey != null) {
    let pkg = await asset.getPackage();

    if (pkg && pkg[packageKey]) {
      return {
        config: pkg[packageKey],
        // The package.json file was already registered by asset.getPackage() -> asset.getConfig()
        files: []
      };
    }
  }

  let conf = await (0, _utils().loadConfig)(asset.options.inputFS, asset.value.filePath, filePaths, parse == null ? null : {
    parse
  });

  if (!conf) {
    return null;
  }

  return conf;
}
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWorkerFarm = createWorkerFarm;
exports.BuildError = exports.default = exports.INTERNAL_RESOLVE = exports.INTERNAL_TRANSFORM = void 0;

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = _interopRequireWildcard(require("@parcel/diagnostic"));

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _Dependency() {
  const data = require("./Dependency");

  _Dependency = function () {
    return data;
  };

  return data;
}

function _Environment() {
  const data = require("./Environment");

  _Environment = function () {
    return data;
  };

  return data;
}

function _Asset() {
  const data = require("./public/Asset");

  _Asset = function () {
    return data;
  };

  return data;
}

function _Bundle() {
  const data = require("./public/Bundle");

  _Bundle = function () {
    return data;
  };

  return data;
}

function _BundleGraph() {
  const data = _interopRequireDefault(require("./public/BundleGraph"));

  _BundleGraph = function () {
    return data;
  };

  return data;
}

function _BundlerRunner() {
  const data = _interopRequireDefault(require("./BundlerRunner"));

  _BundlerRunner = function () {
    return data;
  };

  return data;
}

function _workers() {
  const data = _interopRequireDefault(require("@parcel/workers"));

  _workers = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _AssetGraphBuilder() {
  const data = _interopRequireDefault(require("./AssetGraphBuilder"));

  _AssetGraphBuilder = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("./utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _PackagerRunner() {
  const data = _interopRequireDefault(require("./PackagerRunner"));

  _PackagerRunner = function () {
    return data;
  };

  return data;
}

function _ParcelConfigRequest() {
  const data = require("./requests/ParcelConfigRequest");

  _ParcelConfigRequest = function () {
    return data;
  };

  return data;
}

function _ReporterRunner() {
  const data = _interopRequireWildcard(require("./ReporterRunner"));

  _ReporterRunner = function () {
    return data;
  };

  return data;
}

function _dumpGraphToGraphViz() {
  const data = _interopRequireDefault(require("./dumpGraphToGraphViz"));

  _dumpGraphToGraphViz = function () {
    return data;
  };

  return data;
}

function _resolveOptions() {
  const data = _interopRequireDefault(require("./resolveOptions"));

  _resolveOptions = function () {
    return data;
  };

  return data;
}

function _events() {
  const data = require("@parcel/events");

  _events = function () {
    return data;
  };

  return data;
}

function _cache() {
  const data = require("@parcel/cache");

  _cache = function () {
    return data;
  };

  return data;
}

function _cjsPonyfill() {
  const data = require("abortcontroller-polyfill/dist/cjs-ponyfill");

  _cjsPonyfill = function () {
    return data;
  };

  return data;
}

function _utils2() {
  const data = require("@parcel/utils");

  _utils2 = function () {
    return data;
  };

  return data;
}

function _ParcelConfig() {
  const data = _interopRequireDefault(require("./ParcelConfig"));

  _ParcelConfig = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("@parcel/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError("attempted to get private field on non-instance"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError("attempted to set private field on non-instance"); } if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } return value; }

(0, _utils().registerCoreWithSerializer)();
const INTERNAL_TRANSFORM = Symbol('internal_transform');
exports.INTERNAL_TRANSFORM = INTERNAL_TRANSFORM;
const INTERNAL_RESOLVE = Symbol('internal_resolve');
exports.INTERNAL_RESOLVE = INTERNAL_RESOLVE;

class Parcel {
  /*: AssetGraphBuilder*/

  /*: AssetGraphBuilder*/

  /*: BundlerRunner*/

  /*: PackagerRunner*/

  /*: ParcelConfig*/

  /*: WorkerFarm*/

  /*: InitialParcelOptions*/

  /*: ReporterRunner*/

  /*: AbortController*/

  /*: ?AsyncSubscription*/
  constructor(options) {
    _assetGraphBuilder.set(this, {
      writable: true,
      value: void 0
    });

    _runtimesAssetGraphBuilder.set(this, {
      writable: true,
      value: void 0
    });

    _bundlerRunner.set(this, {
      writable: true,
      value: void 0
    });

    _packagerRunner.set(this, {
      writable: true,
      value: void 0
    });

    _config.set(this, {
      writable: true,
      value: void 0
    });

    _farm.set(this, {
      writable: true,
      value: void 0
    });

    _initialized.set(this, {
      writable: true,
      value:
      /*: boolean*/
      false
    });

    _initialOptions.set(this, {
      writable: true,
      value: void 0
    });

    _reporterRunner.set(this, {
      writable: true,
      value: void 0
    });

    _resolvedOptions.set(this, {
      writable: true,
      value:
      /*: ?ParcelOptions*/
      null
    });

    _watchAbortController.set(this, {
      writable: true,
      value: void 0
    });

    _watchQueue.set(this, {
      writable: true,
      value:
      /*: PromiseQueue<?BuildEvent>*/
      new (_utils2().PromiseQueue)({
        maxConcurrent: 1
      })
    });

    _watchEvents.set(this, {
      writable: true,
      value:
      /*: ValueEmitter<
      | {|
      +error: Error,
      +buildEvent?: void,
      |}
      | {|
      +buildEvent: BuildEvent,
      +error?: void,
      |},
      > */
      new (_events().ValueEmitter)()
    });

    _watcherSubscription.set(this, {
      writable: true,
      value: void 0
    });

    _watcherCount.set(this, {
      writable: true,
      value:
      /*: number*/
      0
    });

    _defineProperty(this, "isProfiling", void 0);

    _classPrivateFieldSet(this, _initialOptions, options);
  }

  async init() {
    var _classPrivateFieldGet2;

    if (_classPrivateFieldGet(this, _initialized)) {
      return;
    }

    let resolvedOptions = await (0, _resolveOptions().default)(_classPrivateFieldGet(this, _initialOptions));

    _classPrivateFieldSet(this, _resolvedOptions, resolvedOptions);

    await (0, _cache().createCacheDir)(resolvedOptions.outputFS, resolvedOptions.cacheDir);
    let {
      config
    } = await (0, _ParcelConfigRequest().loadParcelConfig)(resolvedOptions);

    _classPrivateFieldSet(this, _config, new (_ParcelConfig().default)(config, resolvedOptions.packageManager, resolvedOptions.inputFS, resolvedOptions.autoinstall));

    _classPrivateFieldSet(this, _farm, (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _initialOptions).workerFarm) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : createWorkerFarm({
      patchConsole: resolvedOptions.patchConsole
    })); // ? Should we have a dispose function on the Parcel class or should we create these references
    //  - in run and watch and dispose at the end of run and in the unsubsribe function of watch


    let {
      ref: optionsRef
    } = await _classPrivateFieldGet(this, _farm).createSharedReference(resolvedOptions);
    let {
      ref: configRef
    } = await _classPrivateFieldGet(this, _farm).createSharedReference(config);

    _classPrivateFieldSet(this, _assetGraphBuilder, new (_AssetGraphBuilder().default)());

    _classPrivateFieldSet(this, _runtimesAssetGraphBuilder, new (_AssetGraphBuilder().default)());

    await Promise.all([_classPrivateFieldGet(this, _assetGraphBuilder).init({
      name: 'MainAssetGraph',
      options: resolvedOptions,
      optionsRef,
      entries: resolvedOptions.entries,
      workerFarm: _classPrivateFieldGet(this, _farm)
    }), _classPrivateFieldGet(this, _runtimesAssetGraphBuilder).init({
      name: 'RuntimesAssetGraph',
      options: resolvedOptions,
      optionsRef,
      workerFarm: _classPrivateFieldGet(this, _farm)
    })]);

    _classPrivateFieldSet(this, _bundlerRunner, new (_BundlerRunner().default)({
      options: resolvedOptions,
      runtimesBuilder: _classPrivateFieldGet(this, _runtimesAssetGraphBuilder),
      config: _classPrivateFieldGet(this, _config),
      workerFarm: _classPrivateFieldGet(this, _farm)
    }));

    _classPrivateFieldSet(this, _reporterRunner, new (_ReporterRunner().default)({
      config: _classPrivateFieldGet(this, _config),
      options: resolvedOptions,
      workerFarm: _classPrivateFieldGet(this, _farm)
    }));

    _classPrivateFieldSet(this, _packagerRunner, new (_PackagerRunner().default)({
      config: _classPrivateFieldGet(this, _config),
      farm: _classPrivateFieldGet(this, _farm),
      options: resolvedOptions,
      optionsRef,
      configRef,
      report: _ReporterRunner().report
    }));

    _classPrivateFieldSet(this, _initialized, true);
  }

  async run() {
    let startTime = Date.now();

    if (!_classPrivateFieldGet(this, _initialized)) {
      await this.init();
    }

    let result = await this.build({
      startTime
    });
    await Promise.all([_classPrivateFieldGet(this, _assetGraphBuilder).writeToCache(), _classPrivateFieldGet(this, _runtimesAssetGraphBuilder).writeToCache()]);

    if (!_classPrivateFieldGet(this, _initialOptions).workerFarm) {
      // If there wasn't a workerFarm passed in, we created it. End the farm.
      await _classPrivateFieldGet(this, _farm).end();
    }

    if (result.type === 'buildFailure') {
      throw new BuildError(result.diagnostics);
    }

    return result.bundleGraph;
  }

  async startNextBuild() {
    _classPrivateFieldSet(this, _watchAbortController, new (_cjsPonyfill().AbortController)());

    try {
      _classPrivateFieldGet(this, _watchEvents).emit({
        buildEvent: await this.build({
          signal: _classPrivateFieldGet(this, _watchAbortController).signal
        })
      });
    } catch (err) {
      // Ignore BuildAbortErrors and only emit critical errors.
      if (!(err instanceof _utils().BuildAbortError)) {
        throw err;
      }
    }
  }

  async watch(cb) {
    var _this$watcherCount;

    let watchEventsDisposable;

    if (cb) {
      watchEventsDisposable = _classPrivateFieldGet(this, _watchEvents).addListener(({
        error,
        buildEvent
      }) => cb(error, buildEvent));
    }

    if (_classPrivateFieldGet(this, _watcherCount) === 0) {
      if (!_classPrivateFieldGet(this, _initialized)) {
        await this.init();
      }

      _classPrivateFieldSet(this, _watcherSubscription, (await this._getWatcherSubscription()));

      await _classPrivateFieldGet(this, _reporterRunner).report({
        type: 'watchStart'
      }); // Kick off a first build, but don't await its results. Its results will
      // be provided to the callback.

      _classPrivateFieldGet(this, _watchQueue).add(() => this.startNextBuild());

      _classPrivateFieldGet(this, _watchQueue).run();
    }

    _classPrivateFieldSet(this, _watcherCount, (_this$watcherCount = +_classPrivateFieldGet(this, _watcherCount)) + 1), _this$watcherCount;
    let unsubscribePromise;

    const unsubscribe = async () => {
      var _this$watcherCount2;

      if (watchEventsDisposable) {
        watchEventsDisposable.dispose();
      }

      _classPrivateFieldSet(this, _watcherCount, (_this$watcherCount2 = +_classPrivateFieldGet(this, _watcherCount)) - 1), _this$watcherCount2;

      if (_classPrivateFieldGet(this, _watcherCount) === 0) {
        await (0, _nullthrows().default)(_classPrivateFieldGet(this, _watcherSubscription)).unsubscribe();

        _classPrivateFieldSet(this, _watcherSubscription, null);

        await _classPrivateFieldGet(this, _reporterRunner).report({
          type: 'watchEnd'
        });
        await Promise.all([_classPrivateFieldGet(this, _assetGraphBuilder).writeToCache(), _classPrivateFieldGet(this, _runtimesAssetGraphBuilder).writeToCache()]);
      }
    };

    return {
      unsubscribe() {
        if (unsubscribePromise == null) {
          unsubscribePromise = unsubscribe();
        }

        return unsubscribePromise;
      }

    };
  }

  async build({
    signal,
    startTime = Date.now()
  }) {
    let options = (0, _nullthrows().default)(_classPrivateFieldGet(this, _resolvedOptions));

    try {
      if (options.profile) {
        await this.startProfiling();
      }

      _classPrivateFieldGet(this, _reporterRunner).report({
        type: 'buildStart'
      });

      let {
        assetGraph,
        changedAssets
      } = await _classPrivateFieldGet(this, _assetGraphBuilder).build(signal);
      (0, _dumpGraphToGraphViz().default)(assetGraph, 'MainAssetGraph'); // $FlowFixMe Added in Flow 0.121.0 upgrade in #4381

      let bundleGraph = await _classPrivateFieldGet(this, _bundlerRunner).bundle(assetGraph, {
        signal
      }); // $FlowFixMe Added in Flow 0.121.0 upgrade in #4381 (Windows only)

      (0, _dumpGraphToGraphViz().default)(bundleGraph._graph, 'BundleGraph');
      await _classPrivateFieldGet(this, _packagerRunner).writeBundles(bundleGraph);
      (0, _utils().assertSignalNotAborted)(signal);
      let event = {
        type: 'buildSuccess',
        changedAssets: new Map(Array.from(changedAssets).map(([id, asset]) => [id, (0, _Asset().assetFromValue)(asset, options)])),
        bundleGraph: new (_BundleGraph().default)(bundleGraph, _Bundle().NamedBundle.get, options),
        buildTime: Date.now() - startTime
      };
      await _classPrivateFieldGet(this, _reporterRunner).report(event);
      await _classPrivateFieldGet(this, _assetGraphBuilder).validate();
      return event;
    } catch (e) {
      if (e instanceof _utils().BuildAbortError) {
        throw e;
      }

      let diagnostic = (0, _diagnostic().anyToDiagnostic)(e);
      let event = {
        type: 'buildFailure',
        diagnostics: Array.isArray(diagnostic) ? diagnostic : [diagnostic]
      };
      await _classPrivateFieldGet(this, _reporterRunner).report(event);
      return event;
    } finally {
      if (this.isProfiling) {
        await this.stopProfiling();
      }
    }
  } // $FlowFixMe


  async [INTERNAL_TRANSFORM]({
    filePath,
    env,
    code
  }) {
    let [result] = await Promise.all([_classPrivateFieldGet(this, _assetGraphBuilder).runTransform({
      filePath,
      code,
      env: (0, _Environment().createEnvironment)(env)
    }), _classPrivateFieldGet(this, _reporterRunner).config.getReporters()]);
    return result;
  } // $FlowFixMe


  async [INTERNAL_RESOLVE]({
    moduleSpecifier,
    sourcePath,
    env
  }) {
    let resolved = await _classPrivateFieldGet(this, _assetGraphBuilder).resolverRunner.resolve((0, _Dependency().createDependency)({
      moduleSpecifier,
      sourcePath,
      env: (0, _Environment().createEnvironment)(env)
    }));
    return resolved.filePath;
  }

  _getWatcherSubscription() {
    (0, _assert().default)(_classPrivateFieldGet(this, _watcherSubscription) == null);
    let resolvedOptions = (0, _nullthrows().default)(_classPrivateFieldGet(this, _resolvedOptions));

    let opts = _classPrivateFieldGet(this, _assetGraphBuilder).getWatcherOptions();

    return resolvedOptions.inputFS.watch(resolvedOptions.projectRoot, (err, events) => {
      if (err) {
        _classPrivateFieldGet(this, _watchEvents).emit({
          error: err
        });

        return;
      }

      let isInvalid = _classPrivateFieldGet(this, _assetGraphBuilder).respondToFSEvents(events);

      if (isInvalid && _classPrivateFieldGet(this, _watchQueue).getNumWaiting() === 0) {
        if (_classPrivateFieldGet(this, _watchAbortController)) {
          _classPrivateFieldGet(this, _watchAbortController).abort();
        }

        _classPrivateFieldGet(this, _watchQueue).add(() => this.startNextBuild());

        _classPrivateFieldGet(this, _watchQueue).run();
      }
    }, opts);
  } // This is mainly for integration tests and it not public api!


  _getResolvedParcelOptions() {
    return (0, _nullthrows().default)(_classPrivateFieldGet(this, _resolvedOptions), 'Resolved options is null, please let parcel initialise before accessing this.');
  }

  async startProfiling() {
    if (this.isProfiling) {
      throw new Error('Parcel is already profiling');
    }

    _logger().default.info({
      origin: '@parcel/core',
      message: 'Starting profiling...'
    });

    this.isProfiling = true;
    await _classPrivateFieldGet(this, _farm).startProfile();
  }

  stopProfiling() {
    if (!this.isProfiling) {
      throw new Error('Parcel is not profiling');
    }

    _logger().default.info({
      origin: '@parcel/core',
      message: 'Stopping profiling...'
    });

    this.isProfiling = false;
    return _classPrivateFieldGet(this, _farm).endProfile();
  }

}

exports.default = Parcel;

var _assetGraphBuilder = new WeakMap();

var _runtimesAssetGraphBuilder = new WeakMap();

var _bundlerRunner = new WeakMap();

var _packagerRunner = new WeakMap();

var _config = new WeakMap();

var _farm = new WeakMap();

var _initialized = new WeakMap();

var _initialOptions = new WeakMap();

var _reporterRunner = new WeakMap();

var _resolvedOptions = new WeakMap();

var _watchAbortController = new WeakMap();

var _watchQueue = new WeakMap();

var _watchEvents = new WeakMap();

var _watcherSubscription = new WeakMap();

var _watcherCount = new WeakMap();

class BuildError extends _diagnostic().default {
  constructor(diagnostic) {
    super({
      diagnostic
    });
    this.name = 'BuildError';
  }

}

exports.BuildError = BuildError;

function createWorkerFarm(options = {}) {
  return new (_workers().default)({ ...options,
    workerPath: require.resolve('./worker')
  });
}
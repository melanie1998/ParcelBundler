"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loadPlugin;

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("@parcel/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _plugin() {
  const data = require("@parcel/plugin");

  _plugin = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = _interopRequireWildcard(require("@parcel/diagnostic"));

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _package() {
  const data = require("../package.json");

  _package = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function loadPlugin(fs, packageManager, pluginName, resolveFrom, keyPath, autoinstall) {
  let resolved, pkg;

  try {
    ({
      resolved,
      pkg
    } = await packageManager.resolve(pluginName, resolveFrom, {
      autoinstall
    }));
  } catch (err) {
    let configContents = await fs.readFile(resolveFrom, 'utf8');
    let alternatives = await (0, _utils().findAlternativeNodeModules)(fs, pluginName, _path().default.dirname(resolveFrom));
    throw new (_diagnostic().default)({
      diagnostic: {
        message: `Cannot find parcel plugin "${pluginName}"`,
        origin: '@parcel/core',
        filePath: resolveFrom,
        language: 'json5',
        codeFrame: {
          code: configContents,
          codeHighlights: (0, _diagnostic().generateJSONCodeHighlights)(configContents, [{
            key: keyPath,
            type: 'value',
            message: `Cannot find module "${pluginName}"${alternatives[0] ? `, did you mean "${alternatives[0]}"?` : ''}`
          }])
        }
      }
    });
  } // Validate the engines.parcel field in the plugin's package.json


  let parcelVersionRange = pkg && pkg.engines && pkg.engines.parcel;

  if (!parcelVersionRange) {
    _logger().default.warn({
      origin: '@parcel/core',
      message: `The plugin "${pluginName}" needs to specify a \`package.json#engines.parcel\` field with the supported Parcel version range.`
    });
  }

  if (parcelVersionRange && !_semver().default.satisfies(_package().version, parcelVersionRange)) {
    let pkgFile = (0, _nullthrows().default)((await (0, _utils().resolveConfig)(fs, resolved, ['package.json'])));
    let pkgContents = await fs.readFile(pkgFile, 'utf8');
    throw new (_diagnostic().default)({
      diagnostic: {
        message: `The plugin "${pluginName}" is not compatible with the current version of Parcel. Requires "${parcelVersionRange}" but the current version is "${_package().version}".`,
        origin: '@parcel/core',
        filePath: pkgFile,
        language: 'json5',
        codeFrame: {
          code: pkgContents,
          codeHighlights: (0, _diagnostic().generateJSONCodeHighlights)(pkgContents, [{
            key: '/engines/parcel'
          }])
        }
      }
    });
  }

  let plugin = await packageManager.require(resolved, resolveFrom, {
    autoinstall
  });
  plugin = plugin.default ? plugin.default : plugin;

  if (!plugin) {
    throw new Error(`Plugin ${pluginName} has no exports.`);
  }

  plugin = plugin[_plugin().CONFIG];

  if (!plugin) {
    throw new Error(`Plugin ${pluginName} is not a valid Parcel plugin, should export an instance of a Parcel plugin ex. "export default new Reporter({ ... })".`);
  }

  return {
    plugin,
    version: (0, _nullthrows().default)(pkg).version
  };
}
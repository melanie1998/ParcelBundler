"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@parcel/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _InternalConfig() {
  const data = require("./InternalConfig");

  _InternalConfig = function () {
    return data;
  };

  return data;
}

function _Config() {
  const data = _interopRequireDefault(require("./public/Config"));

  _Config = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ConfigLoader {
  constructor({
    options,
    config
  }) {
    _defineProperty(this, "options", void 0);

    _defineProperty(this, "parcelConfig", void 0);

    _defineProperty(this, "queue", void 0);

    this.options = options;
    this.parcelConfig = config;
    this.queue = new (_utils().PromiseQueue)({
      maxConcurrent: 32
    });
  }

  load(configRequest) {
    let promise = this.queue.add(() => this._load(configRequest));
    this.queue.run().catch(() => {// Do nothing. Promises returned from `add` that will reject if the underlying
      // promise rejects.
    });
    return promise;
  }

  _load(configRequest) {
    if (!configRequest.plugin) {
      return Promise.resolve().then(() => this.loadParcelConfig(configRequest));
    }

    return this.loadPluginConfig(configRequest);
  }

  loadParcelConfig(configRequest) {
    let {
      filePath,
      isSource,
      env,
      pipeline,
      isURL
    } = configRequest;
    let dir = isSource ? _path().default.dirname(filePath) : this.options.projectRoot;

    let searchPath = _path().default.join(dir, 'index');

    let config = (0, _InternalConfig().createConfig)({
      isSource,
      searchPath,
      env
    });
    let publicConfig = new (_Config().default)(config, this.options);
    publicConfig.addIncludedFile(this.parcelConfig.filePath);
    let devDeps = [];

    switch (configRequest.meta.actionType) {
      case 'transformation':
        devDeps = this.parcelConfig.getTransformerNames(filePath, pipeline, isURL);
        break;

      case 'validation':
        devDeps = this.parcelConfig.getValidatorNames(filePath);
        break;

      case 'dependency':
        devDeps = this.parcelConfig.getResolverNames();
        break;
    }

    devDeps.forEach(devDep => publicConfig.addDevDependency(devDep));
    publicConfig.setResultHash((0, _utils().md5FromString)(JSON.stringify(devDeps)));
    publicConfig.setWatchGlob('**/.parcelrc'); // TODO: get included files from plugin nodes
    // TODO: if extended config comes from a package, yarn.lock change should invalidate config request

    return config;
  }

  async loadPluginConfig({
    plugin,
    env,
    isSource,
    filePath,
    meta: {
      parcelConfigPath,
      parcelConfigKeyPath
    }
  }) {
    let config = (0, _InternalConfig().createConfig)({
      isSource,
      searchPath: filePath,
      env
    });
    (0, _assert().default)(typeof parcelConfigPath === 'string');
    (0, _assert().default)(typeof parcelConfigKeyPath === 'string');
    let {
      plugin: pluginInstance
    } = await this.parcelConfig.loadPlugin({
      packageName: (0, _nullthrows().default)(plugin),
      resolveFrom: parcelConfigPath,
      keyPath: parcelConfigKeyPath
    });

    if (pluginInstance.loadConfig != null) {
      await pluginInstance.loadConfig({
        config: new (_Config().default)(config, this.options),
        options: this.options,
        logger: new (_logger().PluginLogger)({
          origin: (0, _nullthrows().default)(plugin)
        })
      });
    }

    return config;
  }

}

exports.default = ConfigLoader;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = _interopRequireWildcard(require("@parcel/diagnostic"));

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _micromatch() {
  const data = _interopRequireDefault(require("micromatch"));

  _micromatch = function () {
    return data;
  };

  return data;
}

function _builtins() {
  const data = _interopRequireDefault(require("./builtins"));

  _builtins = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _module() {
  const data = _interopRequireDefault(require("module"));

  _module = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const EMPTY_SHIM = require.resolve('./_empty');

/**
 * This resolver implements a modified version of the node_modules resolution algorithm:
 * https://nodejs.org/api/modules.html#modules_all_together
 *
 * In addition to the standard algorithm, Parcel supports:
 *   - All file extensions supported by Parcel.
 *   - Glob file paths
 *   - Absolute paths (e.g. /foo) resolved relative to the project root.
 *   - Tilde paths (e.g. ~/foo) resolved relative to the nearest module root in node_modules.
 *   - The package.json module, jsnext:main, and browser field as replacements for package.main.
 *   - The package.json browser and alias fields as an alias map within a local module.
 *   - The package.json alias field in the root package for global aliases across all modules.
 */
class NodeResolver {
  constructor(opts) {
    _defineProperty(this, "fs", void 0);

    _defineProperty(this, "projectRoot", void 0);

    _defineProperty(this, "extensions", void 0);

    _defineProperty(this, "mainFields", void 0);

    _defineProperty(this, "packageCache", void 0);

    _defineProperty(this, "rootPackage", void 0);

    this.extensions = opts.extensions.map(ext => ext.startsWith('.') ? ext : '.' + ext);
    this.mainFields = opts.mainFields;
    this.fs = opts.fs;
    this.projectRoot = opts.projectRoot;
    this.packageCache = new Map();
    this.rootPackage = null;
  }

  async resolve({
    filename,
    parent,
    isURL,
    env
  }) {
    // Get file extensions to search
    let extensions = this.extensions.slice();

    if (parent) {
      // parent's extension given high priority
      let parentExt = _path().default.extname(parent);

      extensions = [parentExt, ...extensions.filter(ext => ext !== parentExt)];
    }

    extensions.unshift('');

    try {
      // Resolve the module directory or local file path
      let module = await this.resolveModule({
        filename,
        parent,
        isURL,
        env
      });

      if (!module) {
        return {
          isExcluded: true
        };
      }

      let resolved;

      if (module.moduleDir) {
        resolved = await this.loadNodeModules(module, extensions, env);
      } else if (module.filePath) {
        if (module.code != null) {
          return {
            filePath: module.filePath,
            code: module.code
          };
        }

        resolved = await this.loadRelative(module.filePath, extensions, env, parent ? _path().default.dirname(parent) : this.projectRoot);
      }

      if (resolved) {
        return {
          filePath: resolved.path,
          sideEffects: resolved.pkg && !this.hasSideEffects(resolved.path, resolved.pkg) ? false : undefined
        };
      }
    } catch (err) {
      if (err instanceof _diagnostic().default) {
        return {
          diagnostics: err.diagnostics
        };
      }
    }

    return null;
  }

  async resolveModule({
    filename,
    parent,
    isURL,
    env
  }) {
    let dir = parent ? _path().default.dirname(parent) : this.fs.cwd(); // If this isn't the entrypoint, resolve the input file to an absolute path

    if (parent) {
      filename = await this.resolveFilename(filename, dir, isURL);
    } // Resolve aliases in the parent module for this file.


    let alias = await this.loadAlias(filename, dir, env);

    if (Array.isArray(alias)) {
      if (alias[0] === 'global') {
        return {
          filePath: `${alias[1]}.js`,
          code: `module.exports=${alias[1]};`
        };
      }

      filename = alias[1];
    } else if (typeof alias === 'string') {
      filename = alias;
    } // Return just the file path if this is a file, not in node_modules


    if (_path().default.isAbsolute(filename)) {
      return {
        filePath: filename
      };
    }

    if (!this.shouldIncludeNodeModule(env, filename)) {
      return null;
    }

    let builtin = this.findBuiltin(filename, env);

    if (builtin || builtin === null) {
      return builtin;
    } // Resolve the module in node_modules


    let resolved;

    try {
      resolved = await this.findNodeModulePath(filename, dir);
    } catch (err) {// ignore
    }

    if (resolved === undefined && process.versions.pnp != null && parent) {
      try {
        let [moduleName, subPath] = this.getModuleParts(filename);

        let pnp = // $FlowFixMe injected at runtime
        require('pnpapi');

        let res = pnp.resolveToUnqualified(moduleName + ( // retain slash in `require('assert/')` to force loading builtin from npm
        filename[moduleName.length] === '/' ? '/' : ''), parent);
        resolved = {
          moduleName,
          subPath,
          moduleDir: res,
          filePath: _path().default.join(res, subPath || '')
        };
      } catch (e) {
        if (e.code !== 'MODULE_NOT_FOUND') {
          return null;
        }
      }
    } // If we couldn't resolve the node_modules path, just return the module name info


    if (resolved === undefined) {
      let [moduleName, subPath] = this.getModuleParts(filename);
      resolved = {
        moduleName,
        subPath
      };
      let alternativeModules = await (0, _utils().findAlternativeNodeModules)(this.fs, resolved.moduleName, dir);

      if (alternativeModules.length) {
        throw new (_diagnostic().default)({
          diagnostic: {
            message: `Cannot find module ${resolved.moduleName}`,
            hints: alternativeModules.map(r => {
              return `Did you mean __${r}__?`;
            })
          }
        });
      }
    }

    return resolved;
  }

  shouldIncludeNodeModule({
    includeNodeModules
  }, name) {
    if (includeNodeModules === false) {
      return false;
    }

    if (Array.isArray(includeNodeModules)) {
      let [moduleName] = this.getModuleParts(name);
      return includeNodeModules.includes(moduleName);
    }

    if (includeNodeModules && typeof includeNodeModules === 'object') {
      let [moduleName] = this.getModuleParts(name);
      let include = includeNodeModules[moduleName];

      if (include != null) {
        return !!include;
      }
    }

    return true;
  }

  async resolveFilename(filename, dir, isURL) {
    switch (filename[0]) {
      case '/':
        {
          // Absolute path. Resolve relative to project root.
          return _path().default.resolve(this.projectRoot, filename.slice(1));
        }

      case '~':
        {
          // Tilde path. Resolve relative to nearest node_modules directory,
          // the nearest directory with package.json or the project root - whichever comes first.
          const insideNodeModules = dir.includes('node_modules');

          while (dir !== this.projectRoot && _path().default.basename(_path().default.dirname(dir)) !== 'node_modules' && (insideNodeModules || !(await this.fs.exists(_path().default.join(dir, 'package.json'))))) {
            dir = _path().default.dirname(dir);

            if (dir === _path().default.dirname(dir)) {
              dir = this.projectRoot;
              break;
            }
          }

          return _path().default.join(dir, filename.slice(1));
        }

      case '.':
        {
          // Relative path.
          return _path().default.resolve(dir, filename);
        }

      default:
        {
          if (isURL) {
            return _path().default.resolve(dir, filename);
          } // Module


          return filename;
        }
    }
  }

  async loadRelative(filename, extensions, env, parentdir) {
    // Find a package.json file in the current package.
    let pkg = await this.findPackage(_path().default.dirname(filename)); // First try as a file, then as a directory.

    let resolvedFile = (await this.loadAsFile({
      file: filename,
      extensions,
      env,
      pkg
    })) || (await this.loadDirectory({
      dir: filename,
      extensions,
      env,
      pkg
    }));

    if (!resolvedFile) {
      // If we can't load the file do a fuzzySearch for potential hints
      let relativeFileSpecifier = (0, _utils().relativePath)(parentdir, filename);
      let potentialFiles = await (0, _utils().findAlternativeFiles)(this.fs, relativeFileSpecifier, parentdir);
      throw new (_diagnostic().default)({
        diagnostic: {
          message: `Cannot load file '${relativeFileSpecifier}' in '${(0, _utils().relativePath)(this.projectRoot, parentdir)}'.`,
          hints: potentialFiles.map(r => {
            return `Did you mean __${r}__?`;
          })
        }
      });
    }

    return resolvedFile;
  }

  findBuiltin(filename, env) {
    if (_builtins().default[filename]) {
      if (env.isNode()) {
        return null;
      }

      return {
        filePath: _builtins().default[filename]
      };
    }
  }

  async findNodeModulePath(filename, dir) {
    let [moduleName, subPath] = this.getModuleParts(filename);

    let root = _path().default.parse(dir).root;

    while (dir !== root) {
      // Skip node_modules directories
      if (_path().default.basename(dir) === 'node_modules') {
        dir = _path().default.dirname(dir);
      }

      try {
        // First, check if the module directory exists. This prevents a lot of unnecessary checks later.
        let moduleDir = _path().default.join(dir, 'node_modules', moduleName);

        let stats = await this.fs.stat(moduleDir);

        if (stats.isDirectory()) {
          return {
            moduleName: moduleName,
            subPath: subPath,
            moduleDir: moduleDir,
            filePath: _path().default.join(dir, 'node_modules', filename)
          };
        }
      } catch (err) {} // ignore
      // Move up a directory


      dir = _path().default.dirname(dir);
    }

    return undefined;
  }

  async loadNodeModules(module, extensions, env) {
    // If a module was specified as a module sub-path (e.g. some-module/some/path),
    // it is likely a file. Try loading it as a file first.
    if (module.subPath && module.moduleDir) {
      let pkg = await this.readPackage(module.moduleDir);
      let res = await this.loadAsFile({
        file: (0, _nullthrows().default)(module.filePath),
        extensions,
        env,
        pkg
      });

      if (res) {
        return res;
      }
    } // Otherwise, load as a directory.


    return this.loadDirectory({
      dir: (0, _nullthrows().default)(module.filePath),
      extensions,
      env
    });
  }

  async isFile(file) {
    try {
      let stat = await this.fs.stat(file);
      return stat.isFile() || stat.isFIFO();
    } catch (err) {
      return false;
    }
  }

  async loadDirectory({
    dir,
    extensions,
    env,
    pkg
  }) {
    let failedEntry;

    try {
      pkg = await this.readPackage(dir);

      if (pkg) {
        // Get a list of possible package entry points.
        let entries = this.getPackageEntries(pkg, env);

        for (let entry of entries) {
          // First try loading package.main as a file, then try as a directory.
          let res = (await this.loadAsFile({
            file: entry.filename,
            extensions,
            env,
            pkg
          })) || (await this.loadDirectory({
            dir: entry.filename,
            extensions,
            env,
            pkg
          }));

          if (res) {
            return res;
          } else {
            failedEntry = entry;
            throw new Error('');
          }
        }
      }
    } catch (e) {
      if (failedEntry && pkg) {
        // If loading the entry failed, try to load an index file, and fall back
        // to it if it exists.
        let indexFallback = await this.loadAsFile({
          file: _path().default.join(dir, 'index'),
          extensions,
          env,
          pkg
        });

        if (indexFallback != null) {
          return indexFallback;
        }

        let fileSpecifier = (0, _utils().relativePath)(dir, failedEntry.filename);
        let alternatives = await (0, _utils().findAlternativeFiles)(this.fs, fileSpecifier, pkg.pkgdir);
        let alternative = alternatives[0];
        let pkgContent = await this.fs.readFile(pkg.pkgfile, 'utf8');
        throw new (_diagnostic().default)({
          diagnostic: {
            message: `Could not load '${fileSpecifier}' from module '${pkg.name}' found in package.json#${failedEntry.field}`,
            language: 'json',
            filePath: pkg.pkgfile,
            codeFrame: {
              code: pkgContent,
              codeHighlights: (0, _diagnostic().generateJSONCodeHighlights)(pkgContent, [{
                key: `/${failedEntry.field}`,
                type: 'value',
                message: `'${fileSpecifier}' does not exist${alternative ? `, did you mean '${alternative}'?` : ''}'`
              }])
            }
          }
        });
      }
    } // Fall back to an index file inside the directory.


    return this.loadAsFile({
      file: _path().default.join(dir, 'index'),
      extensions,
      env,
      pkg: pkg || null
    });
  }

  async readPackage(dir) {
    let file = _path().default.join(dir, 'package.json');

    let cached = this.packageCache.get(file);

    if (cached) {
      return cached;
    }

    let json = await this.fs.readFile(file, 'utf8');
    let pkg = JSON.parse(json);
    pkg.pkgfile = file;
    pkg.pkgdir = dir; // If the package has a `source` field, check if it is behind a symlink.
    // If so, we treat the module as source code rather than a pre-compiled module.

    if (pkg.source) {
      let realpath = await this.fs.realpath(file);

      if (realpath === file) {
        delete pkg.source;
      }
    }

    this.packageCache.set(file, pkg);
    return pkg;
  }

  getPackageEntries(pkg, env) {
    return this.mainFields.map(field => {
      if (field === 'browser' && pkg.browser != null) {
        if (!env.isBrowser()) {
          return null;
        } else if (typeof pkg.browser === 'string') {
          return {
            field,
            filename: pkg.browser
          };
        } else if (typeof pkg.browser === 'object' && pkg.browser[pkg.name]) {
          return {
            field: `browser/${pkg.name}`,
            filename: pkg.browser[pkg.name]
          };
        }
      }

      return {
        field,
        filename: pkg[field]
      };
    }).filter(entry => entry && entry.filename && typeof entry.filename === 'string').map(entry => {
      (0, _assert().default)(entry != null && typeof entry.filename === 'string'); // Current dir refers to an index file

      if (entry.filename === '.' || entry.filename === './') {
        entry.filename = 'index';
      }

      return {
        field: entry.field,
        filename: _path().default.resolve(pkg.pkgdir, entry.filename)
      };
    });
  }

  async loadAsFile({
    file,
    extensions,
    env,
    pkg
  }) {
    // Try all supported extensions
    for (let f of await this.expandFile(file, extensions, env, pkg)) {
      if (await this.isFile(f)) {
        return {
          path: f,
          pkg
        };
      }
    }
  }

  async expandFile(file, extensions, env, pkg, expandAliases = true) {
    // Expand extensions and aliases
    let res = [];

    for (let ext of extensions) {
      let f = file + ext;

      if (expandAliases) {
        let alias = await this.resolveAliases(f, env, pkg);

        if (Array.isArray(alias)) {
          if (alias[0] === 'global') {
            alias = f;
          } else {
            alias = alias[1];
          }
        }

        if (alias !== f) {
          res = res.concat((await this.expandFile(alias, extensions, env, pkg, false)));
        }
      }

      res.push(f);
    }

    return res;
  }

  async resolveAliases(filename, env, pkg) {
    let localAliases = await this.resolvePackageAliases(filename, env, pkg);

    if (Array.isArray(localAliases) || typeof localAliases === 'boolean') {
      return localAliases;
    } // First resolve local package aliases, then project global ones.


    return this.resolvePackageAliases(filename, env, this.rootPackage);
  }

  async resolvePackageAliases(filename, env, pkg) {
    if (!pkg) {
      return filename;
    }

    let pkgKeys = ['source', 'alias'];
    if (env.isBrowser()) pkgKeys.push('browser');

    for (let pkgKey of pkgKeys) {
      let alias = await this.getAlias(filename, pkg.pkgdir, pkg[pkgKey]);
      if (alias != null) return alias;
    }

    return filename;
  }

  async getAlias(filename, dir, aliases) {
    if (!filename || !aliases || typeof aliases !== 'object') {
      return null;
    }

    let alias; // If filename is an absolute path, get one relative to the package.json directory.

    if (_path().default.isAbsolute(filename)) {
      filename = (0, _utils().relativePath)(dir, filename);
      alias = await this.lookupAlias(aliases, filename);
    } else {
      // It is a node_module. First try the entire filename as a key.
      alias = await this.lookupAlias(aliases, (0, _utils().normalizeSeparators)(filename));

      if (alias == null) {
        // If it didn't match, try only the module name.
        let [moduleName, subPath] = this.getModuleParts(filename);
        alias = await this.lookupAlias(aliases, moduleName);

        if (typeof alias === 'string' && subPath) {
          let isRelative = alias.startsWith('./'); // Append the filename back onto the aliased module.

          alias = _path().default.posix.join(alias, subPath); // because of path.join('./nested', 'sub') === 'nested/sub'

          if (isRelative) alias = './' + alias;
        }
      }
    } // If the alias is set to `false`, return an empty file.


    if (alias === false) {
      return ['file', EMPTY_SHIM];
    }

    if (alias instanceof Object) {
      if (alias.global) {
        if (typeof alias.global !== 'string' || alias.global.length === 0) {
          throw new (_diagnostic().default)({
            diagnostic: {
              message: `The global alias for ${filename} is invalid.`,
              hints: [`Only nonzero-length strings are valid global aliases.`]
            }
          });
        }

        return ['global', alias.global];
      } else if (alias.fileName) {
        alias = alias.fileName;
      }
    }

    if (typeof alias === 'string') {
      // Assume file
      return ['file', await this.resolveFilename(alias, dir)];
    }

    return null;
  }

  lookupAlias(aliases, filename) {
    if (typeof aliases !== 'object') {
      return null;
    } // First, try looking up the exact filename


    let alias = aliases[filename];

    if (alias == null) {
      // Otherwise, try replacing glob keys
      for (let key in aliases) {
        let val = aliases[key];

        if (typeof val === 'string' && (0, _utils().isGlob)(key)) {
          let re = _micromatch().default.makeRe(key, {
            capture: true
          });

          if (re.test(filename)) {
            alias = filename.replace(re, val);
            break;
          }
        }
      }
    }

    return alias;
  }

  async findPackage(dir) {
    // Find the nearest package.json file within the current node_modules folder
    let root = _path().default.parse(dir).root;

    while (dir !== root && _path().default.basename(dir) !== 'node_modules') {
      try {
        return await this.readPackage(dir);
      } catch (err) {// ignore
      }

      dir = _path().default.dirname(dir);
    }

    return null;
  }

  async loadAlias(filename, dir, env) {
    // Load the root project's package.json file if we haven't already
    if (!this.rootPackage) {
      this.rootPackage = await this.findPackage(this.projectRoot);
    } // Load the local package, and resolve aliases


    let pkg = await this.findPackage(dir);
    return this.resolveAliases(filename, env, pkg);
  }

  getModuleParts(name) {
    name = _path().default.normalize(name);
    let splitOn = name.indexOf(_path().default.sep);

    if (name.charAt(0) === '@') {
      splitOn = name.indexOf(_path().default.sep, splitOn + 1);
    }

    if (splitOn < 0) {
      return [(0, _utils().normalizeSeparators)(name), undefined];
    } else {
      return [(0, _utils().normalizeSeparators)(name.substring(0, splitOn)), name.substring(splitOn + 1) || undefined];
    }
  }

  hasSideEffects(filePath, pkg) {
    switch (typeof pkg.sideEffects) {
      case 'boolean':
        return pkg.sideEffects;

      case 'string':
        return _micromatch().default.isMatch(_path().default.relative(pkg.pkgdir, filePath), pkg.sideEffects, {
          matchBase: true
        });

      case 'object':
        return pkg.sideEffects.some(sideEffects => this.hasSideEffects(filePath, { ...pkg,
          sideEffects
        }));
    }

    return true;
  }

}

exports.default = NodeResolver;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.anyToDiagnostic = anyToDiagnostic;
exports.errorToDiagnostic = errorToDiagnostic;
exports.generateJSONCodeHighlights = generateJSONCodeHighlights;
exports.getJSONSourceLocation = getJSONSourceLocation;
exports.encodeJSONKeyComponent = encodeJSONKeyComponent;
exports.default = void 0;

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _jsonSourceMap() {
  const data = _interopRequireDefault(require("json-source-map"));

  _jsonSourceMap = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Normalize the given value into a diagnostic. */
function anyToDiagnostic(input) {
  // $FlowFixMe
  let diagnostic = input;

  if (input instanceof ThrowableDiagnostic) {
    diagnostic = input.diagnostics;
  } else if (input instanceof Error) {
    diagnostic = errorToDiagnostic(input);
  }

  return Array.isArray(diagnostic) ? diagnostic : [diagnostic];
}
/** Normalize the given error into a diagnostic. */


function errorToDiagnostic(error, realOrigin) {
  var _error$filePath, _ref2, _error$highlightedCod;

  let codeFrame = undefined;

  if (typeof error === 'string') {
    return [{
      origin: realOrigin !== null && realOrigin !== void 0 ? realOrigin : 'Error',
      message: error,
      codeFrame
    }];
  }

  if (error instanceof ThrowableDiagnostic) {
    return error.diagnostics.map(d => {
      var _ref;

      return { ...d,
        origin: (_ref = realOrigin !== null && realOrigin !== void 0 ? realOrigin : d.origin) !== null && _ref !== void 0 ? _ref : 'unknown'
      };
    });
  }

  if (error.loc && error.source != null) {
    codeFrame = {
      code: error.source,
      codeHighlights: [{
        start: {
          line: error.loc.line,
          column: error.loc.column
        },
        end: {
          line: error.loc.line,
          column: error.loc.column
        }
      }]
    };
  }

  return [{
    origin: realOrigin !== null && realOrigin !== void 0 ? realOrigin : 'Error',
    message: error.message,
    name: error.name,
    filePath: (_error$filePath = error.filePath) !== null && _error$filePath !== void 0 ? _error$filePath : error.fileName,
    stack: (_ref2 = (_error$highlightedCod = error.highlightedCodeFrame) !== null && _error$highlightedCod !== void 0 ? _error$highlightedCod : error.codeFrame) !== null && _ref2 !== void 0 ? _ref2 : error.stack,
    codeFrame
  }];
}

/**
 * An error wrapper around a diagnostic that can be <code>throw</code>n (e.g. to signal a
 * build error).
 */
class ThrowableDiagnostic extends Error {
  constructor(opts) {
    var _diagnostics$0$stack, _diagnostics$0$name;

    let diagnostics = Array.isArray(opts.diagnostic) ? opts.diagnostic : [opts.diagnostic]; // Construct error from diagnostics

    super(diagnostics[0].message);

    _defineProperty(this, "diagnostics", void 0);

    this.stack = (_diagnostics$0$stack = diagnostics[0].stack) !== null && _diagnostics$0$stack !== void 0 ? _diagnostics$0$stack : super.stack;
    this.name = (_diagnostics$0$name = diagnostics[0].name) !== null && _diagnostics$0$name !== void 0 ? _diagnostics$0$name : super.name;
    this.diagnostics = diagnostics;
  }

}
/**
 * Turns a list of positions in a JSON file with messages into a list of diagnostics.
 * Uses <a href="https://github.com/epoberezkin/json-source-map">epoberezkin/json-source-map</a>.
 *
 * @param code the JSON code
 * @param ids A list of JSON keypaths (<code>key: "/some/parent/child"</code>) with corresponding messages, \
 * <code>type</code> signifies whether the key of the value in a JSON object should be highlighted.
 */


exports.default = ThrowableDiagnostic;

function generateJSONCodeHighlights(code, ids) {
  // json-source-map doesn't support a tabWidth option (yet)
  let map = _jsonSourceMap().default.parse(code.replace(/\t/g, ' '));

  return ids.map(({
    key,
    type,
    message
  }) => {
    let pos = (0, _nullthrows().default)(map.pointers[key]);
    return { ...getJSONSourceLocation(pos, type),
      message
    };
  });
}
/**
 * Converts entries in <a href="https://github.com/epoberezkin/json-source-map">epoberezkin/json-source-map</a>'s
 * <code>result.pointers</code> array.
 */


function getJSONSourceLocation(pos, type) {
  if (!type && pos.key && pos.value) {
    // key and value
    return {
      start: {
        line: pos.key.line + 1,
        column: pos.key.column + 1
      },
      end: {
        line: pos.valueEnd.line + 1,
        column: pos.valueEnd.column
      }
    };
  } else if (type == 'key' || !pos.value) {
    (0, _assert().default)(pos.key);
    return {
      start: {
        line: pos.key.line + 1,
        column: pos.key.column + 1
      },
      end: {
        line: pos.keyEnd.line + 1,
        column: pos.keyEnd.column
      }
    };
  } else {
    return {
      start: {
        line: pos.value.line + 1,
        column: pos.value.column + 1
      },
      end: {
        line: pos.valueEnd.line + 1,
        column: pos.valueEnd.column
      }
    };
  }
}
/** Sanitizes object keys before using them as <code>key</code> in generateJSONCodeHighlights */


function encodeJSONKeyComponent(component) {
  return component.replace(/\//g, '~1');
}